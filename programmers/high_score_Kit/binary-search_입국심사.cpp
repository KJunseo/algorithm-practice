/*
    어떻게 이분탐색을 써야할지 감이 안왔었다..
    완전탐색은 무조건 시간초과가 날 것이 분명했다..
    정렬을 해줘야한다고는 생각했는데, 풀지 못하였다.

    가장 중요한 공식은 이것이었다. "추정시간값/각 심사관별 심사시간 = 심사관 당 맡을 수 있는 입국자 수"

    테스트를 예시로 들면, 총 6명의 입국자가 있고, 2명의 심사관의 검사시간은 각각 7분 10분이다.
    최소시간으로 1분(상징적인 값)을 주고, 최대 시간은 10*6=60(제일 오래걸리는 심사관이 모든 입국자를 검사했을 시)이다.
    평균 시간은 (1+60)/2 = 30이다.

    30분 당 심사관1은 30/7 = 4명 심사관2는 30/10 = 3명 총 7명을 검사할 수 있다. 
    그러나 대기자가 6명이므로, 평균시간은 30분보다 작은 것을 알 수 있다.
    따라서 최대 시간을 29로 설정해준다. 

    평균 시간은 15이다. 15분 당 심사관1은 15/7 = 2명 심사관2는 15/10 = 1명 총 3명을 검사할 수 있다.
    우리는 6명을 검사해야하므로, 평균시간은 15분 보다 큰 것을 알 수 있다.
    따라서 최소 시간을 16으로 설정해준다.

    평균 시간은 22이다. 22분 당 심사관 1은 22/7 = 3명 심사관2는 22/10 = 2명 총 5명을 검사할 수 있다.
    우리는 6명을 검사해야하므로, 평균시간은 22보다도 큰 것을 알 수 있다.
    따라서 최소 시간을 23으로 설정해준다.

    평균시간은 26이다. 심사관 1은 26/7 = 3명 심사관 2는 26/10 = 2명, 
    최소 시간을 27로 해준다.

    평균시간은 28이다. 심사관 1은 28/7=4명 심사관 2는 28/10=2명,
    즉 6명이므로, 이 경우가 정답이다.
*/

#include <string>
#include <vector>
#include <algorithm>

using namespace std;

long long solution(int n, vector<int> times) {
    sort(times.begin(), times.end());
    
    long long answer=0;
    long long sum;
    long long mid;
    int numOfExaminer = times.size();
    long long start = 1; // 최소 시간 
    long long end = (long long)times[numOfExaminer-1]*n; // 최대 시간(가장 오래걸리는 심사관이 n명 모두 심사시)
    
    while(start<=end) {
        sum=0;
        mid=(start+end)/2; // 평균 시간 
        
        for(int i=0;i<numOfExaminer;i++) {
            sum+=mid/times[i]; // 각 심사관 당 맡을 수 있는 입국자 수의 총합
        }
        
        // 총합이 입국자 수보다 작으면 
        if(sum<n) {
            start=mid+1; // 평균시간 증가 
        } else { // 총합이 입국자 수보다 크거나 같으면 
            answer=mid; // 정답 업데이트
            end=mid-1; // 평균시간 감소
        }
    }
    
    return answer;
}