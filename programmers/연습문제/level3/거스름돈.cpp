/*
    dfs로 접근했다.
    n을 만족하는 모든 경우는 뽑아낼 수 있었는데 중복을 제거하지 못했다.
    그래서 모든 경우의 수를 벡터에 넣고 erase & unique를 사용했는데 테스트케이스는 통과했지만 segmentation fault가 났다.
    내가 화폐종류가 1~100까지 존재한다고 생각했는데 생각해보니 종류가 100이하라고 했지 1~100이라는 소리는 아니었다.
    그래서 unordered_map 사용하니 정확성에서 테스트8에서 시간초과가 났고, 효율성은 모두 시간초과가 났다.

    dp문제였다...
    1원으로만 n원을 만들 경우 모든 경우의 수는 1이다.
    1, 2원을 사용할 경우 1원을 만드는 경우는 똑같이 1이지만, 2원을 만드는 경우부터는 늘어난다.({1,1}, {2})
    1, 2, 5원을 사용할 경우 4원을 만드는 경우까지는 1, 2원을 사용할 경우와 동일하다. 하지만 5원을 만드는 경우부터 수가 늘어난다.
    규칙을 보면 새로운 동전이 추가될 때 자기자신부터 수가 늘어나고, 그 전 값까지 만들때는 경우의 수가 동일하다는 것을 볼 수 있다.

    dp[n]을 n원을 만드는 경우의 수라고 할 때
    dp[n]=dp[n]+dp[n-사용할 동전의 금액] 이다.
    n-사용할 동전의 금액의 dp값은 해당 동전을 사용했을 때 만들 수 있는 경우의 수이다.

    주어진 동전의 종류를 돌면서 기존 dp[n] 값에 경우의 수를 누적해준다.

    완벽히 이해하지는 못했다.
*/

#include <algorithm>
#include <vector>

using namespace std;

int dp[100001];

int solution(int n, vector<int> money) {
    dp[0]=1; // 0원을 만드는 경우는 1 
    
    sort(money.begin(), money.end());
    
    for(int i=0;i<money.size();i++) { // 동전의 종류를 돌면서 
        for(int j=1;j<=n;j++) { // 1원부터 n원을 만드는 경우
            if(j-money[i]<0) continue; 
            dp[j]=(dp[j]+dp[j-money[i]])%1000000007;
        }
    }
    
    return dp[n];
}